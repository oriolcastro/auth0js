{"version":3,"sources":["../src/authStore.ts","../src/errors.ts","../src/utils.ts","../src/loaderPolicyFunctions.ts"],"sourcesContent":["import {\n  Auth0Client,\n  type Auth0ClientOptions,\n  type GetTokenSilentlyOptions,\n  type IdToken,\n  type LogoutOptions,\n  type RedirectLoginOptions,\n} from '@auth0/auth0-spa-js'\nimport { createStore, StoreApi } from 'zustand'\n\nimport type { Auth0User, SnakeCasedProperties } from './types'\nimport { defaultLogoutReturnTo, tokenError, transformSnakeObjectKeysToCamel } from './utils'\n\ninterface AuthState<TUser extends Auth0User = Auth0User> {\n  /**\n   * Auth0 SDK for SPAs\n   */\n  auth0Client: Auth0Client\n  isLoading: boolean\n  /**\n   * Flag to indicate if the user is authenticated\n   */\n  isAuthenticated: boolean\n  /**\n   * Any error saved in the store while interacting with Auth0\n   */\n  error?: Error\n  /**\n   * The user object\n   *\n   * You can provide it via a generic type or it will default to the User from the Auth0 SDK\n   * @default Auth0User\n   */\n  user?: TUser\n  /**\n   * Internal action DO NOT USE\n   */\n  _actions: {\n    initialised: (user?: TUser) => void\n  }\n  /**\n   * All available actions to interact with Auth0\n   */\n  actions: {\n    /**\n     * ```js\n     * await loginWithRedirect(options);\n     * ```\n     *\n     * Performs a redirect to the `/authorize` route in Auth0 using the parameters provided as arguments.\n     *\n     * @param options\n     */\n    loginWithRedirect: (loginOptions?: RedirectLoginOptions) => Promise<null>\n    /**\n     * ```js\n     * await logout(options);\n     * ```\n     *\n     * Clears the application session and performs a redirect to the login route defind in Auth0\n     *\n     * */\n    logout: (logoutOptions?: LogoutOptions) => Promise<null>\n    /**\n     * ```js\n     * const accessToken = await getAccessTokenSilently(options);\n     * ```\n     *\n     * Fetches a new access token and return it\n     * It also uses it to get an updated user and save it in the store\n     */\n    getAccessTokenSilently: (getTokenOptions?: GetTokenSilentlyOptions) => Promise<string>\n    /**\n     * ```js\n     * const claims = await getIdTokenClaims();\n     * ```\n     *\n     * Returns all claims from the id_token if available.\n     */\n    getIdTokenClaims: () => Promise<IdToken | undefined>\n    /**\n     * ```js\n     * const user =  await updateUser({ givenName: 'Alfredo' });\n     * const user =  await updateUser({ givenName: 'Alfredo' }, { fetchNewToken: true });\n     * ```\n     *\n     * A function to update the user in the store or force a fetching of the information from Auth0\n     */\n    updateUser: (\n      user: Partial<TUser>,\n      options?: { fetchNewToken?: boolean },\n    ) => Promise<TUser | undefined>\n  }\n}\n\n/**\n *  Function factory to create the Zustand store that contains all the state and the different auth methods.\n *  Use this store outside the React tree (ie. `const { isAuthenticated, loginWithRedirect } = authStore.getState()`) or if you only need access to its methods.\n * ```js\n * const authStore = createAuthStore<CustomUserType>({\n *  domain: import.meta.env.VITE_AUTH0_DOMAIN,\n *  clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,\n *  useRefreshTokens: true,\n *  authorizationParams: {\n *    audience: import.meta.env.VITE_AUTH0_AUDIENCE,\n *    redirect_uri: window.location.origin,\n *  },\n * }\n * ```\n *\n * Then you can use the `useStore` hook from Zustand to create the custom hooks (see example).\n * ```js\n * const useUser = useStore(authStore, state => state.user)\n * ```\n * Accepts an optional generic to customize the type for the user object. Use it only if you have extended the IDToken in Auth0 or you use the organizations feature\n *\n * ```ts\n *  interface CustomUserType extends Auth0User {\n *    connection: string\n *    orgId?: string\n *  }\n * ```\n */\nexport const createAuthStore = <TUser extends Auth0User = Auth0User>(options: Auth0ClientOptions) =>\n  createStore<AuthState<TUser>>()((set, get) => ({\n    isLoading: true,\n    isAuthenticated: false,\n    auth0Client: new Auth0Client(options),\n    _actions: {\n      initialised: user =>\n        set(state => ({\n          ...state,\n          isAuthenticated: !!user,\n          user,\n          isLoading: false,\n          error: undefined,\n        })),\n    },\n    actions: {\n      loginWithRedirect: async loginOptions => {\n        const { auth0Client } = get()\n        await auth0Client.loginWithRedirect(loginOptions)\n        return null\n      },\n      logout: async logoutOptions => {\n        const { auth0Client } = get()\n        await auth0Client.logout({\n          ...logoutOptions,\n          logoutParams: { returnTo: defaultLogoutReturnTo, ...logoutOptions?.logoutParams },\n        })\n        return null\n      },\n      getAccessTokenSilently: async getTokenOptions => {\n        const { auth0Client } = get()\n        let token\n\n        try {\n          token = await auth0Client.getTokenSilently(getTokenOptions)\n        } catch (error) {\n          throw tokenError(error as Error)\n        } finally {\n          const auth0User = await auth0Client.getUser<SnakeCasedProperties<TUser>>()\n          if (auth0User) {\n            const user = transformSnakeObjectKeysToCamel(auth0User) as TUser\n\n            set(state =>\n              state.user?.updatedAt === user.updatedAt\n                ? state\n                : { ...state, isAuthenticated: !!user, user },\n            )\n          }\n        }\n        return token\n      },\n      getIdTokenClaims: () => {\n        const { auth0Client } = get()\n        return auth0Client.getIdTokenClaims()\n      },\n      updateUser: async (user, ops = { fetchNewToken: false }) => {\n        if (ops.fetchNewToken) {\n          const { getAccessTokenSilently } = get().actions\n          await getAccessTokenSilently({ cacheMode: 'off' })\n          return get().user\n        }\n        const currentUser = get().user\n        const newUser = { ...currentUser, ...user } as TUser\n        set(state => ({ ...state, user: newUser }))\n        return newUser\n      },\n    },\n  }))\n\nexport type AuthStore<TUser extends Auth0User> = StoreApi<AuthState<TUser>>\n","/**\n * An OAuth2 error will come from the authorization server and will have at least an `error` property which will\n * be the error code. And possibly an `error_description` property\n *\n * See: https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.6\n */\nexport class OAuthError extends Error {\n  constructor(\n    public error: string,\n    public error_description?: string,\n  ) {\n    super(error_description ?? error)\n\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, OAuthError.prototype)\n  }\n}\n","import { OAuthError } from './errors'\nimport { type CamelCasedProperties } from './types'\n\nconst normalizeErrorFn =\n  (fallbackMessage: string) =>\n  (error: Error | { error: string; error_description?: string } | ProgressEvent): Error => {\n    if ('error' in error) {\n      return new OAuthError(error.error, error.error_description)\n    }\n    if (error instanceof Error) {\n      return error\n    }\n    return new Error(fallbackMessage)\n  }\n\nexport const tokenError = normalizeErrorFn('Get access token failed')\n\n// For now we default to return the user to the root route after handling the redirect. At some point we could make it customizable.\nexport const defaultReturnTo = '/'\nexport const defaultLogoutReturnTo = `${window.location.origin}`\n\nexport const snakeToCamelCase = (str: string): string =>\n  str.replace(/([-_][a-z0-9])/gi, $1 => $1.toUpperCase().replace('_', ''))\n\n/**\n * Transform all object keys to camelCase including nested objects and arrays\n */\nexport function transformSnakeObjectKeysToCamel<INPUT extends object>(\n  data: INPUT,\n): CamelCasedProperties<INPUT> {\n  return Object.fromEntries(\n    Object.entries(data).map(([key, val]) => [snakeToCamelCase(key), processVal(val)]),\n  ) as CamelCasedProperties<INPUT>\n}\n\n/** Utility function to transform recursively the value in the object */\nfunction processVal(val: unknown): unknown {\n  return typeof val !== 'object' || val === null\n    ? val\n    : Array.isArray(val)\n    ? val.map(processVal)\n    : transformSnakeObjectKeysToCamel(val)\n}\n","import { type AuthStore } from './authStore'\nimport type { AppState, Auth0User, SnakeCasedProperties } from './types'\nimport { defaultReturnTo, transformSnakeObjectKeysToCamel } from './utils'\n\n/**\n * This is a policy function used to authorize a request in a loader function from react-router\n * @param authStore\n * @param callback\n * @param returnTo\n *\n * @example\n * ```js\n *  async function loader({ request }) {\n *      return authorize(\n *        authStore,\n *        async ({ user }) => {\n *          // here we can get the data for this route and return it.\n *        },\n *        '/welcome'\n *    )\n *  }\n * ```\n */\nexport const authorize = async <TUser extends Auth0User = Auth0User>(\n  authStore: AuthStore<TUser>,\n  callback: (input: { user: TUser }) => Promise<Response>,\n  returnTo = defaultReturnTo,\n) => {\n  const {\n    user,\n    auth0Client,\n    actions: { loginWithRedirect },\n    _actions: { initialised },\n  } = authStore.getState()\n\n  if (user) return callback({ user })\n  await auth0Client.checkSession()\n  const auth0User = await auth0Client.getUser<SnakeCasedProperties<TUser>>()\n\n  if (!auth0User) {\n    return loginWithRedirect({\n      appState: { returnTo },\n      onRedirect: async url => {\n        window.location.replace(url)\n        return new Promise(resolve => {\n          setTimeout(resolve, 1000)\n        })\n      },\n    })\n  }\n  initialised(transformSnakeObjectKeysToCamel(auth0User) as TUser)\n\n  return callback({ user: transformSnakeObjectKeysToCamel(auth0User) as TUser })\n}\n\n/**\n * This is a policy function used to handle the redirection from Auth0\n * @param authStore\n * @param callback\n *\n * @example\n * ```js\n * // loader from route where Auth0 redirects users\n *  async function loader({ request }) {\n *      // handle other flows managed by the same route.\n *\n *      // handle default flow\n *      return handleRedirectCallback(authStore, async ({ appState }) => {\n *          return redirect(appState.returnTo)\n *      })\n *  }\n * ```\n */\nexport const handleRedirectCallback = async <TUser extends Auth0User = Auth0User>(\n  authStore: AuthStore<TUser>,\n  callback: (input: { appState?: AppState }) => Promise<Response>,\n) => {\n  const {\n    auth0Client,\n    _actions: { initialised },\n  } = authStore.getState()\n\n  const { appState } = await auth0Client.handleRedirectCallback<AppState>()\n  const auth0User = await auth0Client.getUser<SnakeCasedProperties<TUser>>()\n\n  initialised(auth0User ? (transformSnakeObjectKeysToCamel(auth0User) as TUser) : undefined)\n\n  return callback({ appState })\n}\n"],"mappings":";AAAA;AAAA,EACE;AAAA,OAMK;AACP,SAAS,mBAA6B;;;ACF/B,IAAM,aAAN,MAAM,oBAAmB,MAAM;AAAA,EACpC,YACS,OACA,mBACP;AACA,UAAM,qBAAqB,KAAK;AAHzB;AACA;AAKP,WAAO,eAAe,MAAM,YAAW,SAAS;AAAA,EAClD;AACF;;;ACbA,IAAM,mBACJ,CAAC,oBACD,CAAC,UAAwF;AACvF,MAAI,WAAW,OAAO;AACpB,WAAO,IAAI,WAAW,MAAM,OAAO,MAAM,iBAAiB;AAAA,EAC5D;AACA,MAAI,iBAAiB,OAAO;AAC1B,WAAO;AAAA,EACT;AACA,SAAO,IAAI,MAAM,eAAe;AAClC;AAEK,IAAM,aAAa,iBAAiB,yBAAyB;AAG7D,IAAM,kBAAkB;AACxB,IAAM,wBAAwB,GAAG,OAAO,SAAS,MAAM;AAEvD,IAAM,mBAAmB,CAAC,QAC/B,IAAI,QAAQ,oBAAoB,QAAM,GAAG,YAAY,EAAE,QAAQ,KAAK,EAAE,CAAC;AAKlE,SAAS,gCACd,MAC6B;AAC7B,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,IAAI,EAAE,IAAI,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,iBAAiB,GAAG,GAAG,WAAW,GAAG,CAAC,CAAC;AAAA,EACnF;AACF;AAGA,SAAS,WAAW,KAAuB;AACzC,SAAO,OAAO,QAAQ,YAAY,QAAQ,OACtC,MACA,MAAM,QAAQ,GAAG,IACjB,IAAI,IAAI,UAAU,IAClB,gCAAgC,GAAG;AACzC;;;AFiFO,IAAM,kBAAkB,CAAsC,YACnE,YAA8B,EAAE,CAAC,KAAK,SAAS;AAAA,EAC7C,WAAW;AAAA,EACX,iBAAiB;AAAA,EACjB,aAAa,IAAI,YAAY,OAAO;AAAA,EACpC,UAAU;AAAA,IACR,aAAa,UACX,IAAI,YAAU;AAAA,MACZ,GAAG;AAAA,MACH,iBAAiB,CAAC,CAAC;AAAA,MACnB;AAAA,MACA,WAAW;AAAA,MACX,OAAO;AAAA,IACT,EAAE;AAAA,EACN;AAAA,EACA,SAAS;AAAA,IACP,mBAAmB,OAAM,iBAAgB;AACvC,YAAM,EAAE,YAAY,IAAI,IAAI;AAC5B,YAAM,YAAY,kBAAkB,YAAY;AAChD,aAAO;AAAA,IACT;AAAA,IACA,QAAQ,OAAM,kBAAiB;AAC7B,YAAM,EAAE,YAAY,IAAI,IAAI;AAC5B,YAAM,YAAY,OAAO;AAAA,QACvB,GAAG;AAAA,QACH,cAAc,EAAE,UAAU,uBAAuB,GAAG,eAAe,aAAa;AAAA,MAClF,CAAC;AACD,aAAO;AAAA,IACT;AAAA,IACA,wBAAwB,OAAM,oBAAmB;AAC/C,YAAM,EAAE,YAAY,IAAI,IAAI;AAC5B,UAAI;AAEJ,UAAI;AACF,gBAAQ,MAAM,YAAY,iBAAiB,eAAe;AAAA,MAC5D,SAAS,OAAO;AACd,cAAM,WAAW,KAAc;AAAA,MACjC,UAAE;AACA,cAAM,YAAY,MAAM,YAAY,QAAqC;AACzE,YAAI,WAAW;AACb,gBAAM,OAAO,gCAAgC,SAAS;AAEtD;AAAA,YAAI,WACF,MAAM,MAAM,cAAc,KAAK,YAC3B,QACA,EAAE,GAAG,OAAO,iBAAiB,CAAC,CAAC,MAAM,KAAK;AAAA,UAChD;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,kBAAkB,MAAM;AACtB,YAAM,EAAE,YAAY,IAAI,IAAI;AAC5B,aAAO,YAAY,iBAAiB;AAAA,IACtC;AAAA,IACA,YAAY,OAAO,MAAM,MAAM,EAAE,eAAe,MAAM,MAAM;AAC1D,UAAI,IAAI,eAAe;AACrB,cAAM,EAAE,uBAAuB,IAAI,IAAI,EAAE;AACzC,cAAM,uBAAuB,EAAE,WAAW,MAAM,CAAC;AACjD,eAAO,IAAI,EAAE;AAAA,MACf;AACA,YAAM,cAAc,IAAI,EAAE;AAC1B,YAAM,UAAU,EAAE,GAAG,aAAa,GAAG,KAAK;AAC1C,UAAI,YAAU,EAAE,GAAG,OAAO,MAAM,QAAQ,EAAE;AAC1C,aAAO;AAAA,IACT;AAAA,EACF;AACF,EAAE;;;AGvKG,IAAM,YAAY,OACvB,WACA,UACA,WAAW,oBACR;AACH,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA,SAAS,EAAE,kBAAkB;AAAA,IAC7B,UAAU,EAAE,YAAY;AAAA,EAC1B,IAAI,UAAU,SAAS;AAEvB,MAAI;AAAM,WAAO,SAAS,EAAE,KAAK,CAAC;AAClC,QAAM,YAAY,aAAa;AAC/B,QAAM,YAAY,MAAM,YAAY,QAAqC;AAEzE,MAAI,CAAC,WAAW;AACd,WAAO,kBAAkB;AAAA,MACvB,UAAU,EAAE,SAAS;AAAA,MACrB,YAAY,OAAM,QAAO;AACvB,eAAO,SAAS,QAAQ,GAAG;AAC3B,eAAO,IAAI,QAAQ,aAAW;AAC5B,qBAAW,SAAS,GAAI;AAAA,QAC1B,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AACA,cAAY,gCAAgC,SAAS,CAAU;AAE/D,SAAO,SAAS,EAAE,MAAM,gCAAgC,SAAS,EAAW,CAAC;AAC/E;AAoBO,IAAM,yBAAyB,OACpC,WACA,aACG;AACH,QAAM;AAAA,IACJ;AAAA,IACA,UAAU,EAAE,YAAY;AAAA,EAC1B,IAAI,UAAU,SAAS;AAEvB,QAAM,EAAE,SAAS,IAAI,MAAM,YAAY,uBAAiC;AACxE,QAAM,YAAY,MAAM,YAAY,QAAqC;AAEzE,cAAY,YAAa,gCAAgC,SAAS,IAAc,MAAS;AAEzF,SAAO,SAAS,EAAE,SAAS,CAAC;AAC9B;","names":[]}